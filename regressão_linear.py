# -*- coding: utf-8 -*-
"""Regressão Linear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FjoyGXii7T2gCs9rgna2WtFYN6jg9yxv
"""

#importado as bibliotecas
import pandas as pd
import plotly.express as px
import seaborn as sns
import numpy as np
import sklearn as sk

#visualizando arquivos da base de dados
base_horas_estudo = pd.read_csv('horas_estudo.csv', sep= ';')

#visualizando arquivos da base de dados
base_horas_estudo.head

#para visualizar algumas estátisticas
base_horas_estudo.describe()

#criação da variavel independente X
x_horas_de_estudo = base_horas_estudo.iloc[:,0].values # buscamos todos os registros da primeira coluna e convertemos em formato de array
# O comando iloc permite selecionar um conjunto de registros.
# O dois pontos ":" significa que estamos selecionando todos os registros e zero "0" a primeira coluna
x_horas_de_estudo

#criando a variavel dependente Y( A que queremos prever)
y_nota_final = base_horas_estudo.iloc[:,1].values
y_nota_final

x_horas_de_estudo_float = np.array([float(valor.replace(',', '.')) for valor in x_horas_de_estudo])

y_nota_final_float = np.array([float(valor.replace(',', '.')) for valor in y_nota_final])

#Vamos verificar os tamanhos dos arrays
print(len(x_horas_de_estudo_float))
print(len(y_nota_final_float))

# Vamos verificar os tipos das variaveis
print(x_horas_de_estudo_float.dtype)

print(y_nota_final_float.dtype)

correlacao = np.corrcoef(x_horas_de_estudo_float, y_nota_final_float)
correlacao #mostramos a matriz

#criaremos um dataframe com essas variaveis
data = pd.DataFrame({'Horas_de_Estudo': x_horas_de_estudo_float, 'Nota_Final': y_nota_final_float})

correlation_matrix = data.corr()

plot = sns.heatmap(correlation_matrix, annot=True, linewidths= 3)
plot
# Usar o seaborn plot nos mostra uma correlação de 66% entre as Horas Estudadas e a Nota Final

"""Perceba que temos uma correlação positiva mediana de 66% pois a medida que as horas de estudo aumentam a nota final também aumenta. Ou seja 66% na nota final pode ser explicada pelas horas de estudo.

### Hora de tratarmos os dados para o modelo
Vamos fazer isso para transformarmos os dadosno formato definido pelo algoritmo solicitado como entrada.
"""

# Visuallizar o formato da variavel
x_horas_de_estudo_float.shape

# Visualizando a variavel
x_horas_de_estudo_float # O resultado nos mostra que temos um array com apenas uma coluna/dimensão. No entanto, precisamos ter uma matriz com 2 colunas.

x_horas_de_estudo_float = x_horas_de_estudo_float.reshape(-1,1)
x_horas_de_estudo_float
# O resultado mostra que convertemos  o array unidimensional para bidimensional(matriz)

# Agora temos uma matriz com 2 colunas e 100 linhas
x_horas_de_estudo_float.shape

"""### Aplicando os dados no algoritmo de machine de regressão
Para isso importaremos a biblioteca sklearn de regressão linear
"""

from sklearn.linear_model import LinearRegression
# cria um objeto do tipo regressão linear
previsao_nota_final = LinearRegression()

type(previsao_nota_final)

"""### Realizando o treinamento do modelo
Nesse caso pegamos o todo o dataset.
"""

previsao_nota_final.fit(x_horas_de_estudo_float, y_nota_final_float)

# Verificando a interceptação ( Cte )
previsao_nota_final.intercept_

# verificando o coeficiente angular da reta( Beta )
previsao_nota_final.coef_

previsao_nota = previsao_nota_final.predict(x_horas_de_estudo_float) # Baseado nos valores de notas já existentes, vamos "prever" ou estimar  as próximas notas

#visualizando as previsãoes para cada nota
previsao_nota

"""### Visualizando no gráfico as disposições dos dados
Vamos utilizar o comando ravel() para  voltar os nossos dados para o formato de vetor
"""

# verificando tipo da variavel x_horas_de_estudo_float
x_horas_de_estudo_float

x_horas_de_estudo_float.ravel() #transformando para vetor

y_nota_final_float # Já esta em formato de vetor

grafico = px.scatter(x = x_horas_de_estudo_float.ravel(), y = y_nota_final_float)
grafico.show()

grafico = px.scatter(x = x_horas_de_estudo_float.ravel(), y = y_nota_final_float)
grafico.add_scatter(x = x_horas_de_estudo_float.ravel(), y = previsao_nota, name= 'previsões')
grafico.show()

#verificando os valores de uma determinada previsão baseada nas notas ( Alfa + Beta * qnt_alunos)
qnt_alunos = 5
previsao_nota_final.intercept_ + previsao_nota_final.coef_ * qnt_alunos

#verificando os valores de uma determinada previsão baseada nas notas ( Alfa + Beta * qnt_alunos)
qnt_alunos = 4
previsao_nota_final.intercept_ + previsao_nota_final.coef_ * qnt_alunos

# Outra forma de verificação é a de modo direto:
previsao_nota_final.predict([[4]])

# Verificamos a qualidade do algoritmo (Quanto mais próximo de 1, melhor a quaidade do modelo)
previsao_nota_final.score(x_horas_de_estudo_float, y_nota_final_float)

# Visualizando Erros do modelo
from sklearn.metrics import mean_squared_error, mean_absolute_error
MSE = mean_squared_error(y_nota_final_float, previsao_nota)

MSE

# Calculando MAE (Erro absoluto = previsão - valor real)
mean_absolute_error(y_nota_final_float, previsao_nota)

# Calculando RMSE (É a raiz quadrada do MSE)
#usamos o RMSE para achar o desvio padrão e assim também podemos identificar outliers
np.sqrt(MSE)

